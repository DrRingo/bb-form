(ns com.drbinhthanh.bb-form
  (:require [babashka.process :refer [shell]]
            [cheshire.core :as json]
            [clojure.java.io :as io]
            [clojure.string :as str]))

;; Atom ƒë·ªÉ l∆∞u tr·ªØ t·∫•t c·∫£ c√¢u tr·∫£ l·ªùi c·ªßa form
(def answers (atom {}))
;; Atom cho d√≤ng tr·∫°ng th√°i/th√¥ng b√°o l·ªói
(def status-line (atom ""))

;; H√†m c·∫≠p nh·∫≠t status-line
(defn set-status! [msg]
  (reset! status-line msg))

;; H√†m x√≥a status-line
(defn clear-status! []
  (reset! status-line ""))

;; H√†m clear m√†n h√¨nh
(defn clear-screen []
  (print "\033[2J")  ;; Clear to√†n b·ªô m√†n h√¨nh
  (print "\033[H"))  ;; Di chuy·ªÉn con tr·ªè v·ªÅ ƒë·∫ßu

;; H√†m render header (title, description, status-line)
(defn render-header [form]
  (println "\nüìù" (:title form))
  (println (:description form) "\n")
  (println (str ":::: " @status-line))
  ;; Lu√¥n th√™m d√≤ng tr·ªëng sau status line ƒë·ªÉ t·∫°o kho·∫£ng c√°ch c·ªë ƒë·ªãnh
  (println))

;; H√†m hi·ªÉn th·ªã th√¥ng b√°o l·ªói v·ªõi GUM
(defn show-error [message]
  (shell {:out :string} "gum" "style" "--foreground" "#ff0000" "--border" "normal" "--border-foreground" "#ff0000" "--margin" "1" "--padding" "1" message)
  ;; Th√™m d√≤ng tr·ªëng sau th√¥ng b√°o l·ªói ƒë·ªÉ t·∫°o kho·∫£ng c√°ch
  (println))

;; H√†m in status-line (lu√¥n in sau ti√™u ƒë·ªÅ/m√¥ t·∫£)
(defn print-status []
  (when (not (str/blank? @status-line))
    (show-error @status-line)))

;; H√†m clear d√≤ng status c≈©
(defn clear-status-line []
  (print "\033[2K")  ;; X√≥a d√≤ng hi·ªán t·∫°i
  (print "\033[1A")  ;; Di chuy·ªÉn l√™n 1 d√≤ng
  (print "\033[2K")) ;; X√≥a d√≤ng ƒë√≥

;; H√†m in l·∫°i status-line (sau khi ƒë√£ clear)
(defn reprint-status []
  (when (not (str/blank? @status-line))
    (show-error @status-line)))

;; -------------------------------
;; Utility functions
;; -------------------------------

;; H√†m chu·∫©n h√≥a string t·ª´ c√°c ki·ªÉu d·ªØ li·ªáu kh√°c nhau
(defn normalize-str [v]
  (cond
    (keyword? v) (name v)
    (symbol? v)  (name v)
    :else (str v)))

;; H√†m chu·∫©n h√≥a key cho branch logic (lowercase v√† trim)
(defn normalize-branch-key [v]
  (-> v normalize-str str/trim str/lower-case))

;; H√†m ki·ªÉm tra xem c√≥ n√™n b·ªè qua field n√†y kh√¥ng (ƒë√£ c√≥ gi√° tr·ªã)
(defn should-skip? [id path]
  (let [field-path (conj path (keyword id))
        v (get-in @answers field-path)]
    (or (and (map? v) (contains? v :_value))
        (and (not (map? v)) (some? v)))))

;; H√†m l·∫•y gi√° tr·ªã ƒë√£ ƒëi·ªÅn tr∆∞·ªõc ƒë√≥ cho field
(defn get-prefilled [id path]
  (let [field-path (conj path (keyword id))
        v (get-in @answers field-path)]
    (if (map? v)
      (:_value v)
      v)))

;; H√†m parse gi√° tr·ªã theo ki·ªÉu d·ªØ li·ªáu
(defn parse-value [v type]
  (case type
    "number" (try (Integer/parseInt (str v)) (catch Exception _ v))
    "text"   (str v)
    "date"   (let [s (str v)]
                 (if (re-matches #"^\d{2}-\d{2}-\d{4}$" s)
                   (try
                     (let [dt (java.time.LocalDate/parse s (java.time.format.DateTimeFormatter/ofPattern "dd-MM-yyyy"))]
                       (.format dt (java.time.format.DateTimeFormatter/ofPattern "yyyy-MM-dd")))
                     (catch Exception _ s))
                   s))
    v))

;; H√†m l·∫•y ng√†y h√¥m nay theo ƒë·ªãnh d·∫°ng DD-MM-YYYY
(defn today []
  (let [now (java.time.LocalDate/now)]
    (.format now (java.time.format.DateTimeFormatter/ofPattern "dd-MM-yyyy"))))

;; H√†m l·∫•y th√°ng v√† nƒÉm hi·ªán t·∫°i
(defn current-month-year []
  (let [now (java.time.LocalDate/now)]
    {:month (.getMonthValue now)
     :year (.getYear now)}))

;; H√†m m·ªü r·ªông c√°c c√°ch g√µ t·∫Øt cho ng√†y th√°ng
(defn expand-date-shortcut [input]
  (let [trimmed (str/trim input)
        {:keys [month year]} (current-month-year)]
    (cond
      ;; G√µ t·∫Øt: "04" -> "04-MM-YYYY" (ng√†y 04 th√°ng hi·ªán t·∫°i nƒÉm hi·ªán t·∫°i)
      (re-matches #"^\d{2}$" trimmed)
      (let [dd (Integer/parseInt trimmed)]
        (format "%02d-%02d-%d" dd month year))
      ;; G√µ t·∫Øt: "1204" -> "12-04-YYYY" (ng√†y 12 th√°ng 04 nƒÉm hi·ªán t·∫°i)
      (re-matches #"^\d{4}$" trimmed)
      (let [dd (Integer/parseInt (subs trimmed 0 2))
            mm (Integer/parseInt (subs trimmed 2 4))]
        (format "%02d-%02d-%d" dd mm year))
      ;; Chuy·ªÉn ƒë·ªïi d·∫•u "/" th√†nh "-" trong ng√†y th√°ng
      (re-matches #"^\d{2}[-/]\d{2}[-/]\d{4}$" trimmed)
      (str/replace trimmed #"[/]" "-")
      :else trimmed)))

;; H√†m ki·ªÉm tra t√≠nh h·ª£p l·ªá c·ªßa ng√†y th√°ng
(defn valid-date? [date-str]
  (if-let [[_ dd mm yyyy] (re-matches #"^(\d{2})-(\d{2})-(\d{4})$" date-str)]
    (let [d (Integer/parseInt dd)
          m (Integer/parseInt mm)
          y (Integer/parseInt yyyy)
          ;; T√≠nh s·ªë ng√†y t·ªëi ƒëa trong th√°ng
          max-day (cond
                     (or (< m 1) (> m 12)) 0  ;; Th√°ng kh√¥ng h·ª£p l·ªá
                     (= m 2) (if (or (zero? (mod y 400)) (and (zero? (mod y 4)) (not (zero? (mod y 100))))) 29 28)  ;; Th√°ng 2 (nƒÉm nhu·∫≠n)
                     (#{4 6 9 11} m) 30  ;; Th√°ng c√≥ 30 ng√†y
                     :else 31)]  ;; Th√°ng c√≥ 31 ng√†y
      (and (<= 1 d max-day)))
    false))

;; H√†m √©p bu·ªôc chuy·ªÉn ƒë·ªïi gi√° tr·ªã th√†nh map
(defn force-map [v]
  (cond
    (map? v) v
    (string? v) {:_value v}
    (number? v) {:_value v}
    (nil? v) {}
    :else {}))

;; -------------------------------
;; GUM UI
;; -------------------------------

;; H√†m x√≥a c√°c d√≤ng l·ªói c≈© tr√™n terminal
(defn clear-error-lines []
  (print "\033[2K")  ;; X√≥a d√≤ng hi·ªán t·∫°i
  (print "\033[1A")  ;; Di chuy·ªÉn l√™n 1 d√≤ng
  (print "\033[2K")  ;; X√≥a d√≤ng ƒë√≥
  (flush))

;; H√†m t·∫°o input field v·ªõi GUM
(defn gum-input [label]
  (-> (shell {:out :string} "gum" "input" "--placeholder" label)
      :out str/trim))

;; H√†m t·∫°o select dropdown v·ªõi GUM
(defn gum-select [label options]
  (-> (apply shell {:out :string}
             (concat ["gum" "choose" "--header" label] options))
      :out str/trim))

;; H√†m t·∫°o multiselect v·ªõi GUM
(defn gum-multiselect [label options]
  (-> (apply shell {:out :string}
             (concat ["gum" "choose" "--no-limit" "--header" label] options))
      :out str/split-lines))

;; -------------------------------
;; Field handling
;; -------------------------------

;; Multimethod ƒë·ªÉ x·ª≠ l√Ω c√°c lo·∫°i field kh√°c nhau
(defmulti ask-field (fn [field & _] (keyword (:type field))))

;; H√†m x·ª≠ l√Ω logic ph√¢n nh√°nh (branching) cho field
(defn handle-branch [branch value path form]
  (let [raw-key (str/trim (str value))
        norm-key (normalize-branch-key value)
        ;; Chu·∫©n h√≥a branch keys ƒë·ªÉ so s√°nh
        norm-branch (into {} (map (fn [[k v]] [(normalize-branch-key k) v]) branch))]
    (when-let [subfields (get norm-branch norm-key)]
      (doseq [sub subfields]
        (let [field-id (last path)
              branch-key (keyword (str (name field-id) "_branch"))
              branch-path (conj (pop path) branch-key (keyword raw-key))]
          (ask-field sub branch-path form))))))

;; Method x·ª≠ l√Ω field text v·ªõi regex validation
(defmethod ask-field :text [{:keys [id label required branch regex regexError]} path form]
  (let [id-k (keyword id)
        value (if (should-skip? id path)
                (get-prefilled id path)
                (loop []
                  (let [v (gum-input label)]
                    ;; Ki·ªÉm tra regex n·∫øu c√≥
                    (if (and regex (not (re-matches (re-pattern regex) v)))
                      (do (set-status! (or regexError (str "Gi√° tr·ªã kh√¥ng kh·ªõp v·ªõi regex: " regex))) (clear-screen) (render-header form) (recur))
                      (do (clear-status!) (clear-screen) (render-header form) v)))))]
    ;; Ch·ªâ l∆∞u gi√° tr·ªã n·∫øu field kh√¥ng b·∫Øt bu·ªôc ho·∫∑c c√≥ gi√° tr·ªã
    (when (or (not required) (not (str/blank? (str value))))
      (swap! answers update-in path #(assoc (force-map %) id-k (parse-value value "text"))))
    ;; X·ª≠ l√Ω branch logic n·∫øu c√≥
    (handle-branch branch value (conj path id-k) form)))

;; Method x·ª≠ l√Ω field number v·ªõi validation s·ªë nguy√™n
(defmethod ask-field :number [{:keys [id label required branch]} path form]
  (let [id-k (keyword id)
        value (if (should-skip? id path)
                (get-prefilled id path)
                (loop []
                  (let [v (gum-input label)]
                    ;; Ki·ªÉm tra xem c√≥ ph·∫£i s·ªë nguy√™n kh√¥ng
                    (if (or (not required)
                            (try (Integer/parseInt v) true (catch Exception _ false)))
                      (do (clear-status!) (clear-screen) (render-header form) v)
                      (do (set-status! "‚ö†Ô∏è Vui l√≤ng nh·∫≠p s·ªë nguy√™n!") (clear-screen) (render-header form) (recur))))))]
    ;; Ch·ªâ l∆∞u gi√° tr·ªã n·∫øu field kh√¥ng b·∫Øt bu·ªôc ho·∫∑c c√≥ gi√° tr·ªã
    (when (or (not required) (not (str/blank? (str value))))
      (swap! answers update-in path #(assoc (force-map %) id-k (parse-value value "number"))))
    ;; X·ª≠ l√Ω branch logic n·∫øu c√≥
    (handle-branch branch value (conj path id-k) form)))

;; Method x·ª≠ l√Ω field date v·ªõi validation v√† g√µ t·∫Øt
(defmethod ask-field :date [{:keys [id label required branch]} path form]
  (let [id-k (keyword id)
        value (if (should-skip? id path)
                (get-prefilled id path)
                (loop []
                  (let [v (gum-input (str label " (DD-MM-YYYY ho·∫∑c g√µ t·∫Øt: 04, 1204)"))]
                    (cond
                      ;; N·∫øu ƒë·ªÉ tr·ªëng, l·∫•y ng√†y h√¥m nay
                      (str/blank? v) (do (clear-status!) (clear-screen) (render-header form) (today))
                      :else
                      (let [expanded (expand-date-shortcut v)]
                        ;; Ki·ªÉm tra t√≠nh h·ª£p l·ªá c·ªßa ng√†y th√°ng
                        (if (not (valid-date? expanded))
                          (do (set-status! "‚ö†Ô∏è Ng√†y th√°ng kh√¥ng h·ª£p l·ªá. V√≠ d·ª•: 31-12-2023") (clear-screen) (render-header form) (recur))
                          (do (clear-status!) (clear-screen) (render-header form) expanded)))))))]
    ;; Ch·ªâ l∆∞u gi√° tr·ªã n·∫øu field kh√¥ng b·∫Øt bu·ªôc ho·∫∑c c√≥ gi√° tr·ªã
    (when (or (not required) (not (str/blank? (str value))))
      (swap! answers update-in path #(assoc (force-map %) id-k (parse-value value "date"))))
    ;; X·ª≠ l√Ω branch logic n·∫øu c√≥
    (handle-branch branch value (conj path id-k) form)))

;; Method x·ª≠ l√Ω field select (dropdown ch·ªçn m·ªôt)
(defmethod ask-field :select [{:keys [id label options branch]} path form]
  (let [id-k (keyword id)
        value (if (should-skip? id path)
                (get-prefilled id path)
                (gum-select label options))]
    ;; L∆∞u gi√° tr·ªã ƒë∆∞·ª£c ch·ªçn
    (swap! answers update-in path #(assoc (force-map %) id-k value))
    ;; X·ª≠ l√Ω branch logic n·∫øu c√≥
    (handle-branch branch value (conj path id-k) form)))

;; Method x·ª≠ l√Ω field multiselect (ch·ªçn nhi·ªÅu)
(defmethod ask-field :multiselect [{:keys [id label options branch]} path form]
  (let [id-k (keyword id)
        raw (if (should-skip? id path)
              (get-prefilled id path)
              (gum-multiselect label options))
        ;; Chu·∫©n h√≥a k·∫øt qu·∫£ multiselect
        choices (cond
                  (string? raw) [raw]
                  (sequential? raw) raw
                  :else [])]
    ;; L∆∞u danh s√°ch c√°c l·ª±a ch·ªçn
    (swap! answers update-in path #(assoc (force-map %) id-k choices))
    ;; X·ª≠ l√Ω branch logic cho t·ª´ng l·ª±a ch·ªçn
    (doseq [choice choices]
      (handle-branch branch choice (conj path id-k) form))))

;; -------------------------------
;; Entry point
;; -------------------------------

;; H√†m ch√≠nh ƒë·ªÉ ch·∫°y form
(defn run-form [form]
  (clear-screen)
  (render-header form)
  ;; Duy·ªát qua t·∫•t c·∫£ c√°c field trong form
  (doseq [field (:fields form)]
    (ask-field field [:selectedByUser] form)))

;; -------------------------------
;; CLI entry point (from run-form.clj)
;; -------------------------------

;; H√†m parse c√°c tham s·ªë key:value t·ª´ command line
(defn parse-kv-args [args]
  (->> args
       (filter #(str/includes? % ":"))
       (map #(str/split % #":" 2))
       (map (fn [[k v]] [(keyword k) v]))
       (into {})))

;; H√†m parse c√°c options t·ª´ command line (--values, --out)
(defn parse-options [args]
  (loop [args args
         opts {}]
    (if (empty? args)
      opts
      (let [[k & rest] args]
        (cond
          ;; Parse option --values
          (= k "--values")
          (if (empty? rest)
            (do (println "‚ùå Thi·∫øu file values sau --values") (System/exit 1))
            (recur (drop 1 rest)
                   (assoc opts :values-file (first rest))))

          ;; Parse option --out
          (= k "--out")
          (if (empty? rest)
            (do (println "‚ùå Thi·∫øu file output sau --out") (System/exit 1))
            (recur (drop 1 rest)
                   (assoc opts :output-file (first rest))))

          ;; B·ªè qua c√°c argument kh√¥ng ph·∫£i option
          (str/starts-with? k "--")
          (do (println (str "‚ùå Option kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£: " k)) (System/exit 1))

          :else
          (recur rest
                 (update opts :kv-args (fnil conj []) k)))))))

;; H√†m main - entry point c·ªßa CLI
(defn -main [& args]
  (let [;; T√¨m file form trong t·∫•t c·∫£ arguments (kh√¥ng ph·∫£i option)
        form-file (first (filter #(and (not (str/starts-with? % "--")) 
                                   (not (str/includes? % ":"))
                                   (str/ends-with? % ".json")) args))
        ;; Parse options t·ª´ t·∫•t c·∫£ arguments
        {:keys [values-file kv-args output-file]} (parse-options args)
        kv-values (parse-kv-args kv-args)
        ;; Load gi√° tr·ªã m·∫∑c ƒë·ªãnh t·ª´ file JSON n·∫øu c√≥
        json-values (if values-file
                      (json/parse-string (slurp values-file) true)
                      {})
        ;; Merge c√°c gi√° tr·ªã t·ª´ command line v√† file JSON
        prefilled (merge json-values kv-values)
        output-path (or output-file "result.json")]
    
    ;; Ki·ªÉm tra xem c√≥ file form kh√¥ng
    (if-not form-file
      (do (println "‚ùå Vui l√≤ng nh·∫≠p ƒë∆∞·ªùng d·∫´n t·ªõi form.json") 
          (println "C√°ch s·ª≠ d·ª•ng: bb-form <form.json> [--values <values.json>] [--out <output.json>]")
          (System/exit 1))
      (let [form (json/parse-string (slurp (io/file form-file)) true)]
        ;; Kh·ªüi t·∫°o atom v·ªõi :selectedByUser l√† map r·ªóng, sau ƒë√≥ merge prefilled
        (reset! answers {:selectedByUser {}})
        (swap! answers update :selectedByUser merge prefilled)
        ;; Ch·∫°y form
        (run-form form)
        ;; T·∫°o th∆∞ m·ª•c n·∫øu ch∆∞a t·ªìn t·∫°i (ch·ªâ khi c√≥ path)
        (let [output-file (io/file output-path)
              parent-dir (.getParentFile output-file)]
          (when parent-dir
            (.mkdirs parent-dir)))
        ;; L∆∞u k·∫øt qu·∫£ ra file JSON
        (spit output-path (json/generate-string @answers {:pretty true}))
        (println (str "\nüíæ ƒê√£ l∆∞u k·∫øt qu·∫£ v√†o " output-path))))))

;; G·ªçi h√†m main v·ªõi command line arguments
(let [args *command-line-args*]
  (apply -main args)) 